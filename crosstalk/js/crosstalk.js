/**
 * @file Contains front-end code for the CrossTalk Analysis Tool
 */

$(document).ready(function () {
  // attach event handlers
  CrossTalk.init({
    description: $('#description'),
    startYear: $('#startYear'),
    startAge: $('#startAge'),
    interval: $('#interval'),
    title1: $('#title1'),
    title2: $('#title2'),
    file1: $('#file1'),
    file2: $('#file2'),
    download: $('#download'),
    calculate: $('#calculate')
  })

  $('#flip').click(CrossTalk.flip)
  $('#clear').click(CrossTalk.clear)
  $('#calculate').click(CrossTalk.calculate)
  $('#crosstalk-tabs').tabCollapse()
  $('#help').click(window.open.bind(
    null, 'help.html', 'Crosstalk Help', 'width=750, height=550, scrollbars=1'))


  $(document).on('show.bs.tab', function (e) {
    if ($(e.target.parentElement).hasClass('disabled'))
      e.preventDefault()
  })

  $(document).on('show.bs.tab', function (e) {
    if ($(e.target.parentElement).hasClass('disabled'))
      e.preventDefault()
  })

  $(document).on('hidden.bs.modal', function (e) {
    $(e.target).find('.modal-body').empty()
  })

  $('.paste-area').bind('paste', function (e) {
    var data = e.originalEvent.clipboardData.getData('text')

    var table = data.match(/[^\r\n]+/g).map(function (line) {
      var values = line.split(/[,\s]/).map(parseFloat)
      return (values.includes(NaN) || values.length % 2) ? null : values
    })

    if (!table.includes(null)) {
      var target = e.target.dataset.target
      var model = $(target).data('model') || {}
      model.table = table
      $(target).data('model', model)

      CrossTalk.update()
    }
  })
})

/**
 * @namespace FileInput
 * @description Handles parsing of input files as data models
 * Exports the following functions to handle file input:
 * FileInput.parse(file : File) : Promise <object, string>
 */
var FileInput = (function () {
  return {
    parse: parseFile
  }

  /**
   * @function parseFile
   * @summary Generates an input object from a file
   * @param {File} file - An input file
   * @returns {PromiseLike<Object>} Returns a promise that resolves to an input object
   * @description An input object has the following properties: 
   * {
   *  title: {string} Description of data 
   *  description: {string} Optional details
   *  startYear: {number} The first year of the first calendar period of the data
   *  startAge: {number} The first age of the first age group of the data
   *  interval: {number} The width of the age and period intervals
   *  table: {number[][]} Table containing count/population data
   * }
   * 
   * @example
   * FileInput
   *   .parse(document.getElementById('file1').files[0])
   *   .then(console.log)
   */
  function parseFile (file) {
    return new Promise(
      function (resolve, reject) {
        if (window.FileReader && file && file instanceof File) {

          /** @type {FileReader} */
          var reader = new FileReader()

          reader.readAsText(file)
          reader.onerror = reject.bind(this, 'Failed to parse input file')

          reader.onload = function (event) {
            // select non-empty lines
            /** @type {string[]} */
            var contents = event.currentTarget.result.match(/[^\r\n]+/g)

            resolve({
              title: parseHeader(contents.shift()),
              description: parseHeader(contents.shift()),
              startYear: parseInt(parseHeader(contents.shift())),
              startAge: parseInt(parseHeader(contents.shift())),
              interval: parseInt(parseHeader(contents.shift())),
              table: contents.map(parseLine)
            })
          }
        }
      }
    )
  }


  /**
   * @function parseLine
   * @summary Parses a line of a csv file as an array of floats 
   * @param {string} line - A line containing comma-separated values
   * @returns {number[]} An array containing parsed numeric values
   */
  function parseLine (line) {
    return line.split(',').map(parseFloat)
  }

  /**
   * @function parseHeader
   * @summary Extracts a header from a line (title, description, etc)
   * @param {string} line - A line containing header data
   * @returns {string} The portion of the line after the first colon
   */
  function parseHeader (line) {
    /** @type {string[]}  */
    var description = line.match(/"(.*?)"/)

    /** @type {string} */
    var header = description ? description[1] : line.split(',')[0]

    return header.substring(header.indexOf(':') + 1).trim()
  }
})()

/**
 * @namespace DataTable
 * @description Creates table nodes generated by DataTables
 * Exports the following functions:
 * DataTable.createEmpty(numRows: number, numCols: number) : HTMLTableElement
 * DataTable.createInput(input: object) : HTMLTableElement
 * DataTable.createOutput(output: object) : HTMLTableElement
 */
var DataTable = (function ($) {
  return {
    createEmpty: createEmptyTable,
    createInput: createInputTable,
    createOutput: createOutputTable
  }

  /**
   * @function createEmptyTable
   * @summary Creates an empty table of the specified size
   * @param {number} numRows - The number of rows
   * @param {number} numCols - The number of columns
   * @returns {HTMLTableElement} An empty table
   */
  function createEmptyTable (numRows, numCols) {
    return createTable(
      createColumns(0, numCols),
      createMatrix(numRows, numCols + 1, '&zwj;'),
      'input-table display cell-border')
  }

  /**
   * @function createInputTable
   * @summary Creates a table for displaying input data
   * @description An input object has the following properties:
   * { 
   *  title: string, 
   *  description: string, 
   *  startYear: number, 
   *  startYear: number,
   *  interval: number,
   *  table: number[][]
   * }
   * 
   * @param {Object} input - The input object to display
   * @returns {HTMLTableElement} A table containing input data
   */
  function createInputTable (input) {
    if (!input || !input.table)
      return null

    // create a table with count/population columns
    var table = createTable(
      createColumns(input.table.length, input.table[0].length),
      getData(input),
      'input-table display cell-border')

    // insert additional table headers
    createHeaders(input).forEach(function (header) {
      table.tHead.insertAdjacentHTML('afterbegin', header.outerHTML)
    })

    return table
  }

  /**
   * @function createOutputTable
   * @summary Creates a table for displaying output data
   * @description An output data array contains objects in the following format
   * [
   *  {columnA: number, columnB: number},
   *  {columnA: number, columnB: number},
   *  ...
   * ]
   * 
   * @param {Object[]} output - The data to display
   * @returns {HTMLTableElement} An HTMLTableElement containing output data
   */
  function createOutputTable (output) {
    return createTable(
      getColumns(output),
      output,
      'output-table display cell-border')
  }

  /**
   * @function createTable
   * @summary Creates a DataTable
   * @description
   * Column data is an array of objects containing properties for each column:
   * [
   *  { 
   *    data: {string=} Corresponding object key, needed only when using objects 
   *    title: {string} The display title for this column 
   *    className: {string} The css class to apply
   *  },
   *  ...
   * ]
   * 
   * 
   * Display data can be either an array of arrays, or an array objects
   * 
   * Array of arrays:
   * [
   *  [valueA, valueB, valueC],
   *  [valueA, valueB, valueC],
   *  ...
   * ]
   * 
   * Array of objects:
   * [
   *  {columnA: number, columnB: number},
   *  {columnA: number, columnB: number},
   *  ...
   * ]
   *  
   * @param {{data: string, title: string, className: string}[]} columns - The column names of the data
   * @param {Object[]|number[][]} data - The data to display
   * @param {string} classname - The css classes to apply to this table
   */
  function createTable (columns, data, classname) {

    /** @type {HTMLTableElement} */
    var table = document.createElement('table')
    table.className = classname
    table.width = '100%'

    $(table).DataTable({
      destroy: true,
      columns: columns,
      data: data,
      bSort: false,
      bFilter: false,
      paging: false,
      responsive: true,
      dom: 't'
    })

    return table
  }

  /**
   * @function createHeaders
   * @summary Creates table headers for input data
   * @description
   * An input model has the following properties:
   * {
   *  title: {string} Description of data 
   *  description: {string} Optional details
   *  startYear: {number} The first year of the first calendar period of the data
   *  startAge: {number} The first age of the first age group of the data
   *  interval: {number} The width of the age and period intervals
   *  table: {number[][]} Table containing count/population data
   * }
   * 
   * @param {Object} model - The input object to create table headers for
   * @returns {HTMLTableRowElement[]} Table rows containing header information
   */
  function createHeaders (model) {

    // limit length of title and description
    var title = (model.title.length > 100) ? (model.title.substr(0, 100) + '...') : model.title
    var desc = (model.description.length > 100) ? (model.description.substr(0, 100) + '...') : model.description

    console.log('description', desc)

    // create table row for title header
    /** @type HTMLTableRowElement */
    var titleRow = document.createElement('tr')

    // create spacer for both headers
    /** @type HTMLTableHeaderElement */
    var spacer = document.createElement('th')
    spacer.style.visibility = 'hidden'
    spacer.rowSpan = 2
    titleRow.appendChild(spacer)

    // create header for title/description
    /** @type HTMLTableHeaderElement */
    var titleHeader = document.createElement('th')
    titleHeader.className = 'table-header'
    titleHeader.colSpan = model.table[0].length
    titleHeader.innerHTML = (title || ('Created ' + new Date().toLocaleString())) +
      ('<div class="blue">' + desc + '</div>')
    titleRow.appendChild(titleHeader)

    // create row for year ranges
    /** @type HTMLTableRowElement */
    var yearRow = document.createElement('tr')

    /** @type number */
    var endYear = model.startYear + model.interval * model.table[0].length / 2

    // add each header to the row
    for (var year = model.startYear; year < endYear; year += model.interval) {
      /** @type HTMLTableHeaderElement */
      var yearHeader = document.createElement('th')
      yearHeader.className = 'grey'
      yearHeader.colSpan = 2

      // if year interval is one, display single years instead of a year range
      /** @type string */
      var yearRange = model.interval > 1
        ? [year, year + model.interval - 1].join('-')
        : year

      yearHeader.innerText = yearRange
      yearRow.appendChild(yearHeader)
    }

    return [yearRow || null, titleRow || null]
  }

  /**
   * @function createColumns
   * @summary Creates alternating count/population columns for the input table
   * @description
   * Creates column names in the following format:
   * [
   *  { 
   *    title: {string} 'Age' | 'N Age Groups'
   *    className: {string} 'grey'
   *  },
   *  { 
   *    title: {string} 'Count' 
   *    className: {string} 'dt-body-right'
   *  },
   *  { 
   *    title: {string} 'Population' 
   *    className: {string} 'dt-body-right'
   *  },
   *  ...
   * ]
   * 
   * @param {number} numRows The number of rows in this table
   * @param {number} numCols The number of columns in this table
   * @returns {Object[]} Column names used by DataTables
   */
  function createColumns (numRows, numCols) {
    /** @type Object[] */
    var columns = [{
      title: numRows
        ? '<small>' + numRows + ' age groups</small>'
        : 'Age',
      className: numRows ? 'grey' : 'grey'
    }]

    while (numCols--)
    columns.push({
        title: numCols % 2 ? 'Count' : 'Population',
        className: 'dt-body-right'
      })

    return columns
  }

  /**
   * @function createMatrix
   * @summary Creates a matrix with a specified initial size and fill value
   * @param {number} numRows - The number of rows in this matrix
   * @param {number} numCols - The number of columns in this matrix
   * @param {string | number} initialValue - The fill value for this matrix
   * @returns {(string|number)[][]} A matrix of the specified size
   */
  function createMatrix (numRows, numCols, initialValue) {
    return Array(numRows)
      .fill(Array(numCols)
        .fill(initialValue || null))
  }

  /**
   * @function getData
   * @summary Prepends age ranges to each row in the input table
   * @description 
   * An input model contains the following properties:
   * {
   *  title: {string} Description of data 
   *  description: {string} Optional details
   *  startYear: {number} The first year of the first calendar period of the data
   *  startAge: {number} The first age of the first age group of the data
   *  interval: {number} The width of the age and period intervals
   *  table: {number[][]} Table containing count/population data
   * }
   * 
   * @param {Object} model
   * @returns {(string|number)[][]} A matrix containing age, count, and population data
   */
  function getData (model) {
    return model.table.map(function (row, index) {
      // calculates the age from the starting age, index and interval
      var age = model.startAge + index * model.interval || ''

      if (model.interval > 1)
        age += '-' + (age + model.interval - 1)

      return [age].concat(row)
    })
  }

  /**
   * @function getColumns
   * @summary Creates column headers from the output table
   * @description
   * An output object is an array of Objects:
   * [
   *  {columnA: number, columnB: number},
   *  {columnA: number, columnB: number},
   *  ...
   * ]
   * 
   * Column data is an array of objects containing properties for each column:
   * [
   *  { 
   *    data: {string=} Corresponding object key, needed only when using objects 
   *    title: {string} The display title for this column 
   *    className: {string} The css class to apply
   *  },
   *  ...
   * ]
   * 
   * @param {Object[]} output
   * @returns
   */
  function getColumns (output) {
    /** @type string[] */
    var keys = Object.keys(output[0])

    /** @type string */
    var label = ''

    // re-order keys if row names are present
    if (keys[keys.length - 1] === '_row') {
      keys.unshift(keys.pop())
      if (output[0]._row.match(/[0-9]/))
        label = 'Age'
    }

    return keys.map(function (key) {
      return {
        data: key,

        // do not display a title for columns containing row names
        title: key === '_row'
          ? label
          : key,

        // center-align columns containing row names
        className: ['_row', 'Cohort', 'Age', 'Period', 'Per', 'Coh'].includes(key)
          ? 'dt-body-center'
          : 'dt-body-right'
      }
    })
  }
})(window.jQuery)

/**
 * @namespace Plot
 * @description Creates plots using SVG and Canvas
 * Exports the following functions to handle plot generation:
 * Plot.createSVG(data, titles) : Element
 * Plot.createCanvas(data, titles) : HTMLCanvasElement
 */
var Plot = (function () {
  return {
    createSVG: createSVG,
    createCanvas: createCanvas
  }

  /**
   * @function createSVG
   * @summary Creates an svg area plot
   * @description
   * The input data is an object with the following properties:
   * {
   *  title {string} The plot title
   *  legends {string[]} Legend labels
   *  xlabel {string} The x-axis label
   *  ylabel {string} The y-axis label
   *  xaxis {string} The x-axis data key
   *  yaxis {string} The y-axis data key
   *  curves {{xaxis, yaxis, 'CILo', 'CiHi'}[]} Curve data
   *  bands {number[min, max][]} Band data
   * }
   * @param {Object} data
   * @returns {HTMLDivElement} A responsive div wrapping the SVG plot
   */
  function createSVG (data) {

    /** @type string[] */
    var colors = ['#1D628B', '#E74C3C', '#2C3E50']

    /** @type HTMLDivElement */
    var svgContainer = document.createElement('div')
    svgContainer.className = 'svg-container'

    /**
     * @type {
     *  outerWidth {number} - The outer width of the plot
     *  outerHeight {number} - The outer height of the plot
     *  width {number} - The inner width of the plot
     *  height {number} - The inner height of the plot
     *  margin {top: number, right: number, bottom: number, left: number}
     *  xscale {d3.scaleLinear} - A function for scaling values across the x-axis
     *  yscale {d3.scaleLinear} - A function for scaling values across the y-axis
     *  line {d3.line} - A function for drawing lines in a specific context
     *  area {d3.area} - A function for drawing an area in a specific context
     * }
     */
    var plot = createPlot(data)

    /** @type d3.scaleLinear */
    var x = plot.xscale

    /** @type d3.scaleLinear */
    var y = plot.yscale

    /** @type {top: number, right: number, bottom: number, left: number} */
    var margin = plot.margin

    /** @type number */
    var outerWidth = plot.outerWidth

    /** @type number */
    var outerHeight = plot.outerHeight

    /** @type number */
    var width = plot.width

    /** @type number */
    var height = plot.height

    /** @type d3.scaleLinear */
    var x = plot.xscale

    /** @type d3.scaleLinear */
    var y = plot.yscale

    /** @type d3.line */
    var line = plot.line

    /** @type d3.area */
    var area = plot.area

    /** @type d3.svg */
    var svg = d3.select(svgContainer).append('svg')
      .attr('viewBox', '0 0 ' + outerWidth + ' ' + outerHeight)
      .append('g')
      .attr('transform',
        sprintf('translate(%d, %d)', margin.left, margin.top))

    /** @type d3.div */
    var tooltip = d3.select('body').append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)

    // draw legend
    data.legends.forEach(function (title, index) {
      /** @type number */
      var size = 20

      /** @type number */
      var spacing = 10

      /** @type number */
      var yloc = (size + spacing) * index

      // draw legend color square
      svg.append('rect')
        .attr('x', width - size)
        .attr('y', yloc)
        .attr('width', size)
        .attr('height', size)
        .attr('fill', colors[index])

      // draw legend text
      svg.append('text')
        .attr('x', width - size - spacing / 2)
        .attr('y', yloc + size * 0.7)
        .attr('font-size', 10)
        .style('text-anchor', 'end')
        .text(title)
    })

    data.curves.forEach(function (curve, index) {
      // draw area ribbon
      svg.append('path')
        .data([curve])
        .attr('class', 'area')
        .attr('d', area)
        .attr('fill', colors[index])
        .attr('fill-opacity', '0.3')

      // draw curve
      svg.append('path')
        .data([curve])
        .attr('class', 'line')
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke', colors[index])
        .attr('stroke-opacity', '0.5')
    })

    data.bands.forEach(function (band, index) {
      // draw each band
      svg.append('rect')
        .attr('class', 'area')
        .attr('x', 0)
        .attr('y', y(band[1]))
        .attr('width', width)
        .attr('height', y(band[0]) - y(band[1]))
        .attr('fill', colors[index])
        .attr('fill-opacity', '0.2')
    })

    // draw points over other elements
    data.curves.forEach(function (curve, index) {
      curve.forEach(function (point) {

        /** @type {HTMLTableElement} */
        var tooltipContents = (function (headers, values) {
          var table = document.createElement('table')

          headers.forEach(function (header, index) {
            var row = document.createElement('tr')
            var contents = [header + ':', values[index]]

            contents.forEach(function (data) {
              var cell = document.createElement('td')
              cell.innerHTML = data
              row.appendChild(cell)
            })

            table.appendChild(row)
          })

          return table
        })([data.xaxis, data.yaxis, 'CILo', 'CIHi'],
          [point[data.xaxis], point[data.yaxis], point.CILo, point.CIHi])

        svg.append('circle')
          .attr('class', 'point')
          .attr('r', 4)
          .attr('cx', x(point[data.xaxis]))
          .attr('cy', y(point[data.yaxis]))
          .attr('fill', colors[index])
          .attr('fill-opacity', '1.0')
          .attr('data-toggle', 'tooltip')
          .on('mouseover', function (d) {
            var xoffset = (d3.event.pageX / window.outerWidth > 0.7) ? -165 : 5
            tooltip.transition()
              .duration(200)
              .style('opacity', .9)
              .style('background-color', colors[index % colors.length])
            tooltip.html(tooltipContents.outerHTML)
              .style('left', (d3.event.pageX + xoffset) + 'px')
              .style('top', (d3.event.pageY - 80) + 'px')
          })
          .on('mouseout', function (d) {
            tooltip.transition()
              .duration(300)
              .style('opacity', 0)
          })
      })
    })

    // add x-axis
    svg.append('g')
      .attr('transform', sprintf('translate(0, %d)', height))
      .call(d3.axisBottom(x).tickFormat(d3.format('d')))

    // add x-axis label
    svg.append('text')
      .attr('transform',
        sprintf('translate(%d, %d)', width / 2, height + margin.top + 20))
      .style('text-anchor', 'middle')
      .text(data.xlabel)

    // add y-axis
    svg.append('g').call(d3.axisLeft(y))

    // add y-axis label
    svg.append('text')
      .attr('transform', 'rotate(-90)')
      .attr('y', 0 - margin.left)
      .attr('x', 0 - (height / 2))
      .attr('dy', '1em')
      .style('text-anchor', 'middle')
      .text(data.ylabel)

    return svgContainer
  }

  /**
   * @function createCanvas
   * @summary Creates an area plot on a Canvas element (for exporting as base64)
   * @description
   * This function replaces a svg -> canvas rendering library used to maintain
   * compatibility with IE (due to a cross-origin security issue raised when
   * exporting canvas objects with svg content).
   * 
   * The input data is an object with the following properties:
   * {
   *  title {string} The plot title
   *  legends {string[]} Legend labels
   *  xlabel {string} The x-axis label
   *  ylabel {string} The y-axis label
   *  xaxis {string} The x-axis data key
   *  yaxis {string} The y-axis data key
   *  curves {{xaxis, yaxis, 'CILo', 'CiHi'}[]} Curve data
   *  bands {number[min, max][]} Band data
   * }
   * @param {Object} data
   * @returns {HTMLCanvasElement} A canvas object containing the plot
   */
  function createCanvas (data) {

    /** @type string[] */
    var colors = ['#1D628B', '#E74C3C', '#2C3E50']

    /** @type {HTMLCanvasElement} */
    var canvas = document.createElement('canvas')

    /** @type {CanvasRenderingContext2D} */
    var context = canvas.getContext('2d')

    /**
     * @type {
     *  outerWidth {number} - The outer width of the plot
     *  outerHeight {number} - The outer height of the plot
     *  width {number} - The inner width of the plot
     *  height {number} - The inner height of the plot
     *  margin {top: number, right: number, bottom: number, left: number}
     *  xscale {d3.scaleLinear} - A function for scaling values across the x-axis
     *  yscale {d3.scaleLinear} - A function for scaling values across the y-axis
     *  line {d3.line} - A function for drawing lines in a specific context
     *  area {d3.area} - A function for drawing an area in a specific context
     * }
     */
    var plot = createPlot(data)
    canvas.width = plot.outerWidth
    canvas.height = plot.outerHeight

    /** @type number */
    var width = plot.width

    /** @type number */
    var height = plot.height

    /** @type d3.scaleLinear */
    var x = plot.xscale

    /** @type d3.scaleLinear */
    var y = plot.yscale

    /** @type {top: number, right: number, bottom: number, left: number} */
    var margin = plot.margin

    /** @type d3.line */
    var line = plot.line.context(context)

    /** @type d3.area */
    var area = plot.area.context(context)

    context.translate(margin.left, margin.top)

    context.fillStyle = 'white'
    context.fillRect(-margin.left, -margin.top, outerWidth, outerHeight)
    context.fillStyle = 'black'

    xAxis()
    yAxis()
    legend()

    // draw curves
    data.curves.forEach(function (curve, index) {
      context.beginPath()
      area(curve)
      context.fillStyle = colors[index]
      context.globalAlpha = 0.4
      context.fill()

      context.beginPath()
      line(curve)
      context.lineWidth = 1.5
      context.strokeStyle = colors[index]
      context.globalAlpha = 0.5
      context.stroke()

      // draw points
      curve.forEach(function (point) {
        var xloc = x(point[data.xaxis])
        var yloc = y(point[data.yaxis])
        var radius = 4

        context.beginPath()
        context.globalAlpha = 1
        context.arc(xloc, yloc, radius, 0, Math.PI * 2)
        context.fill()
      })
    })

    // draw each band
    data.bands.forEach(function (band, index) {
      context.beginPath()
      context.fillStyle = colors[index]
      context.globalAlpha = 0.4
      context.fillRect(0, y(band[1]), width, y(band[1]) - y(band[0]))
    })

    return canvas

    /**
     * @function xAxis
     * @Summary creates the x-axis for this plot
     */
    function xAxis () {
      var tickCount = 10
      var tickSize = 5
      var ticks = x.ticks(tickCount)
      var tickFormat = x.tickFormat()
      context.textAlign = 'center'
      context.textBaseline = 'top'
      context.font = '10px sans-serif'

      // draw axis line
      context.beginPath()
      context.moveTo(0, height - 0.5)
      context.lineTo(width, height - 0.5)
      context.strokeStyle = '#000000'
      context.stroke()

      // draw axis ticks
      ticks.forEach(function (d) {
        // handle straddling of pixels
        var xval = Math.floor(x(d)) + 0.5

        context.beginPath()
        context.moveTo(xval, height)
        context.lineTo(xval, height + tickSize)
        context.strokeStyle = '#000000'
        context.stroke()

        context.beginPath()
        context.moveTo(xval, height - 1)
        context.lineTo(xval, 0)
        context.strokeStyle = '#EEEEEE'
        context.stroke()

        context.fillText(tickFormat(d), xval, height + tickSize)
      })

      context.textAlign = 'right'
      context.textBaseline = 'bottom'
      context.font = 'bold 11px sans-serif'
      context.fillText(data.xlabel, width, height - tickSize - 5)
    }

    /**
     * @function yAxis
     * @Summary creates the y-axis for this plot
     */
    function yAxis () {
      var tickCount = 10
      var tickSize = 5
      var tickPadding = 3
      var ticks = y.ticks(tickCount)
      var tickFormat = y.tickFormat(tickCount)
      context.textAlign = 'right'
      context.textBaseline = 'middle'
      context.font = '10px sans-serif'

      // draw axis line
      context.beginPath()
      context.moveTo(0.5, 0)
      context.lineTo(0.5, height)
      context.strokeStyle = '#000000'
      context.stroke()

      // draw axis ticks
      ticks.forEach(function (d) {
        var yval = Math.floor(y(d)) + 0.5

        context.beginPath()
        context.moveTo(0, yval)
        context.lineTo(-tickSize, yval)
        context.strokeStyle = '#000000'
        context.stroke()

        context.beginPath()
        context.moveTo(1, yval)
        context.lineTo(width, yval)
        context.strokeStyle = '#EEEEEE'
        context.stroke()

        context.fillText(tickFormat(d), -tickSize - tickPadding, yval)
      })

      // draw axis label
      context.save()
      context.rotate(-Math.PI / 2)
      context.textAlign = 'right'
      context.textBaseline = 'top'
      context.font = 'bold 11px sans-serif'
      context.fillText(data.ylabel, 0, 10)
      context.restore()
    }

    /**
     * @function legend
     * @Summary creates the legend for this plot
     */
    function legend () {
      context.textAlign = 'right'
      context.textBaseline = 'top'
      context.font = 'bold 11px sans-serif'

      data.legends.forEach(function (title, index) {
        var size = 20
        var spacing = 10

        var yloc = (size + spacing) * index

        context.beginPath()
        context.fillStyle = colors[index]
        context.fillRect(width - size, yloc, size, size)
        context.fillText(title, width - size - spacing / 2, yloc + spacing / 2)
      })
    }
  }

  /**
   * @function createPlot 
   * @summary Creates default d3 axes/area curves for the data
   * The input data is an object with the following properties:
   * {
   *  title {string} The plot title
   *  legends {string[]} Legend labels
   *  xlabel {string} The x-axis label
   *  ylabel {string} The y-axis label
   *  xaxis {string} The x-axis data key
   *  yaxis {string} The y-axis data key
   *  curves {{xaxis, yaxis, 'CILo', 'CiHi'}[]} Curve data
   *  bands {number[min, max][]} Band data
   * }
   * 
   * The output of this function is an object with the following properties:
   * {
   *  outerWidth {number} - The outer width of the plot
   *  outerHeight {number} - The outer height of the plot
   *  width {number} - The inner width of the plot
   *  height {number} - The inner height of the plot
   *  margin {top: number, right: number, bottom: number, left: number}
   *  xscale {d3.scaleLinear} - A function for scaling values across the x-axis
   *  yscale {d3.scaleLinear} - A function for scaling values across the y-axis
   *  line {d3.line} - A function for drawing lines in a specific context
   *  area {d3.area} - A function for drawing an area in a specific context
   * }
   * 
   * @param {Object} data - The data containing area/curve data 
   * @returns {Object} - An object containing d3 functions for generating lines
   */
  function createPlot (data) {

    /** @type number */
    var outerWidth = 600

    /** @type number */
    var outerHeight = 600

    /** @type {top: number, right: number, bottom: number, left: number} */
    var margin = {
      top: 20,
      right: 20,
      bottom: 50,
      left: 50
    }

    /** @type number */
    var width = outerWidth - margin.left - margin.right

    /** @type number */
    var height = outerHeight - margin.top - margin.bottom

    /** @type d3.scaleLinear */
    var x = d3.scaleLinear()

    /** @type d3.scaleLinear */
    var y = d3.scaleLinear()

    /** @type d3.line */
    var line = d3.line()
      .x(function (d) { return x(d[data.xaxis]) })
      .y(function (d) { return y(d[data.yaxis]) })

    /** @type d3.area */
    var area = d3.area()
      .x(function (d) { return x(d[data.xaxis]) })
      .y0(function (d) { return y(d.CILo) })
      .y1(function (d) { return y(d.CIHi) })

    var xvals = []
    var yvals = []

    data.curves.forEach(function (curve) {
      curve.forEach(function (el) {
        xvals.push(el[data.xaxis])
        yvals.push(el[data.yaxis], el.CILo, el.CIHi)
      })
    })

    x.range([0, width])
      .domain(d3.extent(xvals))

    /** @type number[] */
    var ydomain = d3.extent(yvals)
    ydomain[1] = ydomain[1] * 1.25

    y.range([height, 0])
      .domain(ydomain)

    return {
      outerWidth: outerWidth,
      outerHeight: outerHeight,
      width: width,
      height: height,
      margin: margin,
      xscale: x,
      yscale: y,
      line: line,
      area: area
    }
  }
})()

/**
 * @namespace Modal
 * @description Displays modal dialogs
 * Exports the following functions:
 * Modal.displayTable(title: string, tables: Object[])
 * Modal.displayImage(title: string, source : string)
 * Modal.displayElement(title : string, body : Element)
 */
var Modal = (function () {
  return {
    displayTable: displayOutputTable,
    displayImage: displayImage,
    displayElement: displayElement
  }

  /**
   * @function displayOutputTable
   * @summary Displays an output table in a modal dialog
   * @description
   * An output table is represented by an array of objects in this format: 
   * An output object is an array of Objects:
   * [
   *  {columnA: number, columnB: number},
   *  {columnA: number, columnB: number},
   *  ...
   * ]
   * 
   * @param {string} title - The title of the modal dialog
   * @param {Object[]} tables - The output data to display
   */
  function displayOutputTable (title, tables) {
    var container = document.createElement('div')

    tables.forEach(function (table, index) {
      /** @type HTMLDivElement */
      var tableDiv = document.createElement('div')
      tableDiv.className = 'table-responsive '

      if (index > 0)
        tableDiv.className += 'vertical-spacer'

      tableDiv.appendChild(DataTable.createOutput(table))
      container.appendChild(tableDiv)
    })

    displayElement(title, container)
  }

  /**
   * @function displayImage
   * @summary Displays an image in a modal dialog
   * @param {string} title - The title of the modal dialog
   * @param {string} source - The source of the image
   */
  function displayImage (title, source) {
    /** @type HTMLImageElement */
    var image = new Image()

    image.src = src
    image.style.width = '100%'
    image.className = 'img-responsive'

    displayElement(title, image)
  }

  /**
   * @function displayElement
   * @summary Displays an HTML element in a modal dialog
   * @param {string} title - The title of the modal
   * @param {Element} body - The element to display
   */
  function displayElement (title, body) {
    var cfg = {
      container: $('#modalDialog'),
      title: $('#modalTitle'),
      body: $('#modalBody')
    }

    cfg.title.html(title)
    cfg.body.html(body)
    cfg.container.modal('show')
  }
})()

/**
 * @namespace Excel
 * @description Exports results data as an excel document
 * Exports the following functions:
 * Excel.exportData(data : Object[])
 */
var Excel = (function () {
  return {
    exportData: exportData
  }

  function exportData (data) {
    var workbook = new ExcelBuilder.Workbook()

    data.forEach(function (sheetData, index) {
      workbook.addWorksheet(generateSheet(workbook, sheetData, index))
    })

    ExcelBuilder.Builder.createFile(workbook).then(
      download.bind(null, sprintf('CrossTalk_Analysis_%s.xlsx', getTimestamp()), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    )
  }

  function generateSheet (workbook, sheetData, index) {
    if (sheetData.title.endsWith('Labeled'))
      sheetData.title = sheetData.title.replace('- Labeled', '')

    var titleString = sheetData.title.split(' - ')
    var title = index + 1

    if (titleString.length < 2)
      title = [title, titleString[0]].join(' - ')
    else
      title = [title, titleString[0], titleString.pop()].join(' - ')

    if (title.length > 31)
      title = title.substr(0, 30)

    var worksheet = workbook.createWorksheet({name: title})
    console.log(sheetData)

    // add tables
    var table = mergeTables(sheetData.tables)

    // add title for sheet
    console.log('ABC', table)
    if (table && table.length) {
      var titleArr = Array(table[0].length - 1).fill('')
      titleArr.unshift(sheetData.title)
      table.unshift(Array(table[0].length).fill(''))
      table.unshift(titleArr)
      worksheet.setData(table)
    } else {
      worksheet.setData([[sheetData.title]])
    }

    // add graphs
    var drawings = new ExcelBuilder.Drawings()
    var width = 600
    var height = 600

    if (title.includes('Incidence Rate Ratios')) {
      width = 55 * table[0].length
      height = 60 * table.length
    }

    sheetData.graphs.forEach(function (graph, index) {
      var graphref = workbook.addMedia(
        'image',
        randomString(10) + '.png',
        graph.replace('data:image/png;base64,', ''))

      var graphpic = new ExcelBuilder.Drawing.Picture()
      graphpic.createAnchor('oneCellAnchor', {
        x: index * Math.max((table && table[0] ? table[0].length / 2 : 10), 10),
        y: table.length + 2,
        width: ExcelBuilder.Positioning.pixelsToEMUs(width),
        height: ExcelBuilder.Positioning.pixelsToEMUs(height)
      })

      graphpic.setMedia(graphref)
      drawings.addDrawing(graphpic)
    })
    worksheet.addDrawings(drawings)
    workbook.addDrawings(drawings)

    return worksheet
  }

  function mergeTables (tables) {
    var table = []
    var converted = tables.map(convertTable)

    if (converted.length === 4) {
      var temp1 = converted[0].concat(Array(4).fill('')).concat(converted[1])
      var temp2 = converted[2].concat(Array(4).fill('')).concat(converted[3])
      converted = [temp1, temp2]
    }

    converted.forEach(function (matrix, index) {
      matrix.forEach(function (array, index2) {
        table[index2] = (table[index2] || []).concat(array).concat(Array(3).fill(''))
      })
    })


    return table
  }



  // converts an array of objects to a regular matrix
  function convertTable (table) {
    var headers = Object.keys(table[0])
    if (headers[headers.length - 1] === '_row')
      headers.unshift(headers.pop())

    var converted = [headers]

    for (var i = 0; i < table.length; i++) {
      var row = []
      for (var j = 0; j < headers.length; j++) {
        var header = headers[j]
        row.push(table[i][header])
      }
      converted.push(row)
    }

    if (converted[0][0] === '_row')
      converted[0][0] = ''

    return converted
  }

  function download (filename, type, data) {
    var bytechars = atob(data)
    var bytenums = new Array(bytechars.length)

    for (var i = 0; i < bytechars.length; i++)
      bytenums[i] = bytechars.charCodeAt(i)

    var bytearr = new Uint8Array(bytenums)
    var blob = new Blob([bytearr], {type: type})

    if (window.navigator.msSaveOrOpenBlob)
      window.navigator.msSaveBlob(blob, filename)
    else {
      var element = window.document.createElement('a')
      element.href = window.URL.createObjectURL(blob)

      if (typeof element.download != 'undefined')
        element.download = filename
      else
        alert('Please open the downloaded file in Microsoft Excel')

      document.body.appendChild(element)
      element.click()
      document.body.removeChild(element)
    }
  }

  function getTimestamp () {
    var date = new Date()

    return [date.getHours(), date.getMinutes(), date.getSeconds()].join('_')
  }

  function randomString (length) {
    return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, length)
  }
})()

/**
 * @namespace CrossTalk
 * @description Creates input models, handles ajax calls,
 * and populates the DOM with results
 * 
 * Exports the following functions:
 * CrossTalk.init(config: Object) - sets input fields and attaches event handlers
 * CrossTalk.flip() - flips both input tables
 * CrossTalk.clear() - resets the DOM
 * CrossTalk.calculate() - calls the calculation and updates the DOM with results
 */
var CrossTalk = (function () {

  // Holds DOM references
  /** @type Object */
  var cfg = {
    description: null,
    startYear: null,
    startAge: null,
    interval: null,
    title1: null,
    title2: null,
    file1: null,
    file2: null,
    download: null,
    calculate: null
  }

  /** @type Object[] */
  var excelData = []

  return {
    init: init,
    flip: flip,
    clear: clear,
    calculate: calculate,
    update: updateUI
  }

  /**
   * @function init
   * @summary Saves DOM references in the configuration and attaches event handlers
   * @description
   * A configuration object has the following properties:
   * {
   *  description {jQuery.HTMLInputElement} - A text input for the description 
   *  startYear {jQuery.HTMLInputElement} - A numeric input for the starting year 
   *  startAge {jQuery.HTMLInputElement} - A numeric input for the starting age
   *  interval {jQuery.HTMLSelectElement} - A selector for the interval length
   *  title1 {jQuery.HTMLInputElement} - A text input for the first dataset's title
   *  file1 {jQuery.HTMLInputElement} - A file input element for the first dataset
   *  title2 {jQuery.HTMLInputElement} - A text input for the second dataset's title
   *  file2 {jQuery.HTMLInputElement} - A file input element for the second dataset
   *  download {jQuery.HTMLSelectElement} - A selector for the download types
   *  calculate {jQuery.HTMLButtonElement} - A button to initiate the calculation
   * }
   * 
   * @param {Object} config
   */
  function init (config) {
    cfg = config

    for (element in cfg)
      cfg[element].change(update)

    cfg.download.click(function () {
      var link = $('#download-format').val()

      if (link == 'Excel Output')
        Excel.exportData(excelData)
      else if (link.startsWith('tmp'))
        window.open(link, 'download')
    })

    $('a[href="#Input"]').tab('show')
    $('ul.nav.nav-pills li:not(:first)').addClass('disabled')
    $('#download-results').hide()
    updateUI()
  }


  /**
   * @function update
   * @summary Updates the UI
   * @this The input element that fired this event
   */
  function update () {
    var element = $(this)

    // Updates the UI based on the contents of the file
    if (this.type === 'file')
      FileInput.parse(this.files[0])
        .then(function (model) {
          // set the title of the model to match the appropriate index and store it
          model[element.data('title').substring(1)] = model.title

          // store the model data in the element
          element.data({'model': model})

          // update the UI, passing in the updated file model
          updateUI(model)
        })
    else {
      updateUI()
    }
  }

  /**
   * @function updateUI
   * @summary Updates UI based on file contents and form data
   * @description
   * A file model contains the following properties:
   * {
   *  title: {string} Description of data 
   *  description: {string} Optional details
   *  startYear: {number} The first year of the first calendar period of the data
   *  startAge: {number} The first age of the first age group of the data
   *  interval: {number} The width of the age and period intervals
   *  table: {number[][]} Table containing count/population data
   * }
   * 
   * @param {Object} [model] A file model to update the UI with
   */
  function updateUI (model) {


    // if a file model was supplied, update the corresponding form elements as well
    if (model)
      for (key in model)
        if (cfg[key])
          cfg[key].val(model[key])

    // update goodness-of-fit tab
    var selectors = ['a[href="#GoodnessOfFit-A"]', 'a[href="#GoodnessOfFit-B"]']
    selectors.forEach(function (selector, index) {
      $(selector).text(cfg['title' + (index + 1)].val())
    })

    // update both data tables based on file/form contents
    var inputs = [cfg.file1, cfg.file2]
    inputs.forEach(function (element) {
      // generate a table if the model contains data, otherwise create an empty table

      if (element[0].files.length || (element.data('model') && element.data('model').table)) {
        /** @type HTMLTableElement */
        var table = DataTable.createInput(getTable(element))
        $('#flip').show()
      } else {
        /** @type HTMLTableElement */
        var table = DataTable.createEmpty(12, 6)
        $('#flip').hide()
      }

      // data.table is a reference to the DOM node containing the table
      $(element.data('table')).find('table').DataTable().destroy()
      $(element.data('table')).append(table)
    })
  }

  function flip () {
    var swap = cfg.title2.val()
    cfg.title2.val(cfg.title1.val())
    cfg.title1.val(swap)

    swap = cfg.file2.data('model')
    cfg.file2.data('model', cfg.file1.data('model'))
    cfg.file1.data('model', swap)

    updateUI()

    // update file references afterwards to reduce performance impact
    swap = cfg.file2.prop('files')
    cfg.file2.prop('files', cfg.file1.prop('files'))
    cfg.file1.prop('files', swap)
  }

  function clear () {
    for (element in cfg)
      cfg[element].val('')

    cfg.file1.data('model', null)
    cfg.file2.data('model', null)

    $('#Input').children('#errors').remove()
    init(cfg)
  }

  function getModel () {
    return {
      description: cfg.description.val(),
      startYear: parseInt(cfg.startYear.val()),
      startAge: parseInt(cfg.startAge.val()),
      interval: parseInt(cfg.interval.val()),
      title1: cfg.title1.val(),
      title2: cfg.title2.val(),
      file1: cfg.file1.data('model'),
      file2: cfg.file2.data('model')
    }
  }

  function getTable (element) {
    return {
      description: cfg.description.val(),
      startYear: parseInt(cfg.startYear.val()),
      startAge: parseInt(cfg.startAge.val()),
      interval: parseInt(cfg.interval.val()),
      title: $(element.data('title')).val(),
      table: element.data('model') ? element.data('model').table : null
    }
  }

  function validate () {
    var input1 = cfg.file1.data('model')
    var input2 = cfg.file2.data('model')

    var valid = $('#crosstalk-form')[0].checkValidity()

    if (input1 && input2) {
      if (input1.table.length != input2.table.length || input1.table[0].length != input2.table[0].length) {
        cfg.file1[0].setCustomValidity('The contents of Data Files must have the same dimensions')
      } else {
        cfg.file1[0].setCustomValidity('')
        cfg.file2[0].setCustomValidity('')
      }
    } else {
      if (!input1 || !input1.table)
        cfg.file1[0].setCustomValidity('Data File 1 is required')
      else
        cfg.file1[0].setCustomValidity('')

      if (!input2 || !input2.table)
        cfg.file2[0].setCustomValidity('Data File 2 is required')
      else
        cfg.file2[0].setCustomValidity('')
    }

    $('#Input.tab-pane').children('#errors').remove()
    $('.errors').removeClass('errors')

    var invalids = $('input:invalid, select:invalid')
    if (invalids.length > 0)

      $.each($('input:invalid, select:invalid'), function (i, el) {
        displayErrors(el)
      })
    else
      return true
  }

  function calculate () {
    if (validate()) {
      $('#Input').children('#error').remove()

      var url = '/crosstalkRest/calculate/'

      if (!cfg.description.val())
        cfg.description.val('Created ' + new Date().toLocaleString())

      var model = getModel()
      $('#loading').modal('show')

      $.post(url, JSON.stringify(model))
        .done(displayResults)
        .fail(displayError)
        .always(function () {
          $('#loading').modal('hide')
        })
    }
  }

  function displayError (xhr, error, statusText) {
    var message = ''
    switch (xhr.status) {
      case 503:
        message = 'The service that the request is trying to reach is currently down, Please try again later'
        break
      case 404:
        message = "The request returned with a response of  '" + statusText + "'. Please try again later."
        break
      case 400:
        message = xhr.responseJSON.data
        break
      default:
        message = 'The request has failed for an unknown reason'
        break
    }

    console.error(message)

    $('#Input').children('#error').remove()
    $('#Input').prepend($("<div id='error' class='alert alert-danger'>").html(message))
  }

  function displayResults (results) {
    results = JSON.parse(results)

    var downloads = results.downloads
    var output = results.output

    for (key in output)
      populate(key, output[key])

    for (key in downloads)
      $('#' + key).prop('value', downloads[key])

    $('#download-results').show()
    $('ul.nav.nav-pills li:not(:first)').removeClass('disabled')
    $('a[href="#IncidenceRates"]').tab('show')
  }

  function populate (key, content) {
    if (content.graphs || content.tables)
      $('#' + key).html(createPanel(key, content))

    else
      for (subkey in content)
        populate([key, subkey].join('-'), content[subkey])
  }

  function createPanel (key, content) {
    var panelData = {
      title: null,
      tables: [],
      graphs: []
    }

    var panel = $('<div>')
    panel.addClass('row')

    console.log('PANEL', key, content)

    content.graphs.forEach(function (graph, i) {
      var graphDiv = $('<div>')
      var singleTable = (content.tables.length % 2) === 1
      var singleGraph = (content.graphs.length % 2) === 1
      var classname = singleGraph ? 'col-md-12' : 'col-md-6'
      var titles = singleTable ? [cfg.title1.val() + ' vs ' + cfg.title2.val()] : [cfg.title1.val(), cfg.title2.val()]


      graphDiv.addClass(classname + ' text-center')

      var graph = content.graphs[i]
      var title = key
        .split('-').join(' -')
        .split(/(?=[A-Z])/).join(' ')

      if (key.endsWith('A'))
        title += ' - ' + cfg.title1.val()
      else if (key.endsWith('B'))
        title += ' - ' + cfg.title2.val()

      if (typeof graph === 'string') {
        var img = $('<img>')
        img.addClass('img-responsive')
        img.data('title', key)
        img.attr('src', graph)
        img.attr('data-action', 'zoom')

        img.click(Modal.displayElement.bind(
          img, title, img.clone().removeAttr('data-action')
        ))

        panelData.graphs.push(graph)
        graphDiv.append(img)
      } else {
        // draw svg graph
        var svgWrapper = $(Plot.createSVG(graph, titles))
        svgWrapper.attr('data-action', 'zoom')

        // render canvas plot to base64

        graphDiv.data('title', title)
        graphDiv.data('graph', graph)

        graphDiv.click(Modal.displayElement.bind(
          graphDiv, graphDiv.data('title'), Plot.createSVG(graphDiv.data('graph'), titles)
        ))

        panelData.graphs.push(Plot.createCanvas(graph, titles).toDataURL('image/png'))
        graphDiv.append(svgWrapper)
      }

      panelData.title = title
      panel.append(graphDiv)
    })

    for (var j = 0; j < content.tables.length; j++) {
      var linkDiv = $('<div>')
      var single = (content.tables.length % 2) === 1
      var classname = single ? 'col-md-12' : 'col-md-6'
      var linkname = single ? (cfg.title1.val() + ' vs ' + cfg.title2.val()) : cfg['title' + (j + 1)].val()

      linkDiv.addClass(classname + ' text-center vertical-spacer')

      var tableLink = $('<a>')
      console.log('getting the tables for ', key, content.tables)

      tableLink.data({title: linkname, tables: content.tables[j]})

      tableLink.click(function () {
        var data = $(this).data()
        Modal.displayTable(data.title, data.tables)
      })

      tableLink.html('View Dataset ' + linkname)
      linkDiv.append(tableLink)

      if (content.tables[j].length) {
        panel.append(linkDiv)

        content.tables[j].forEach(function (table) {
          panelData.tables.push(table)
        })
      }
    }

    if (!panelData.title.includes('Unlabeled'))
      excelData.push(panelData)

    return panel
  }

  function displayErrors (el) {
    if ($('#errors').length === 0)
      $('#Input.tab-pane').prepend("<div id='errors' class='alert alert-danger'></div>")

    var label = $("label[for='" + el.id + "']")
    label.addClass('errors')
    var msg = ''

    if (el.validity.badInput) {
      msg += "'" + label[0].innerText + "' contains an invalid value </br>"
    }
    if (el.validity.valueMissing) {
      msg += "'" + label[0].innerText + "' is required </br>"
    }

    if (el.validity.customError) {
      msg += el.validationMessage + '</br>'
    }

    $('#errors').append(msg)
  }
})()
